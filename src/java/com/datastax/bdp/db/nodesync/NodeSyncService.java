/*
 * Copyright DataStax, Inc.
 *
 * Please see the included license file for details.
 */
package com.datastax.bdp.db.nodesync;

import java.lang.management.ManagementFactory;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import javax.management.InstanceAlreadyExistsException;
import javax.management.MBeanServer;
import javax.management.ObjectName;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.util.concurrent.Uninterruptibles;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.datastax.bdp.db.utils.concurrent.CompletableFutures;
import org.apache.cassandra.config.NodeSyncConfig;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.metrics.AbstractMetricNameFactory;
import org.apache.cassandra.metrics.NodeSyncMetrics;
import org.apache.cassandra.metrics.MetricNameFactory;
import org.apache.cassandra.metrics.TableMetrics;
import org.apache.cassandra.repair.SystemDistributedKeyspace;
import org.apache.cassandra.schema.Schema;
import org.apache.cassandra.schema.TableMetadata;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.utils.Throwables;
import org.apache.cassandra.utils.units.RateUnit;
import org.apache.cassandra.utils.units.RateValue;

/**
 * The NodeSync service, which continuously and iteratively validates that this node is in sync with any other replica
 * with which it shares a range (for a table on which NodeSync is enabled).
 * <p>
 * Technically, the NodeSync service mainly group a {@link ValidationScheduler} and a {@link ValidationExecutor}. The
 * scheduler will continuously generate new validation to execute, and the executor will execute them.
 */
public class NodeSyncService implements NodeSyncServiceMBean
{
    private static final Logger logger = LoggerFactory.getLogger(NodeSyncService.class);

    /**
     * The minimum delay we enforce between doing 2 validation on the same segment.
     * <p>
     * This exists because on very small clusters (typically brand new empty ones) we might end up validating everything
     * in a very very short time, and it doesn't feel very meaningful to re-validate the empty system distributed tables
     * every 50ms (which is what happens without this on an empty cluster). Note that the amount of resources devoted to
     * NodeSync is globally guarded by {@link NodeSyncConfig#rateLimiter} so the importance of this shouldn't be
     * over-stated but 1) this feels reasonable and 2) we don't account for validations over empty data with the limiter
     * (since it rate limits validated bytes) but there is costs associated to creating the validation in the first place
     * (reading the {@link SystemDistributedKeyspace#NodeSyncStatus} table mostly) and this prevents this to get out of
     * hand.
     */
    // publicly Visible because we warn if user are setting a deadline lowe than this in NodeSyncParams and that's outside the nodesync package
    public static final String MIN_VALIDATION_INTERVAL_PROP_NAME = "dse.nodesync.min_validation_interval_ms";
    public static final long MIN_VALIDATION_INTERVAL_MS = Long.getLong(MIN_VALIDATION_INTERVAL_PROP_NAME, TimeUnit.MINUTES.toMillis(5));

    static final long MIN_WARN_INTERVAL_MS = TimeUnit.SECONDS.toMillis(Long.getLong("dse.nodesync.min_warn_interval_sec",
                                                                                    TimeUnit.HOURS.toSeconds(10)));


    private static final MetricNameFactory factory = new AbstractMetricNameFactory(JMX_GROUP,
                                                                                   "NodeSyncMetrics");
    /**
     * Lifetime metrics (for the node) on the NodeSync service (Per-table metrics are also recorded through {@link TableMetrics}).
     */
    private final NodeSyncMetrics metrics = new NodeSyncMetrics(factory, "NodeSync");

    // A proxy to the system status table; exists for testing.
    final NodeSyncStatusTableProxy statusTableProxy;
    private final NodeSyncConfig config = DatabaseDescriptor.getNodeSyncConfig();

    // Will be null if NodeSync isn't running. Is set to non-null only inside synchronized methods so as to ensure we
    // never run 2 instances at once.
    private volatile Instance instance;

    /**
     * Group everything we need when the NodeSync service is running, and don't when it isn't.
     */
    class Instance
    {
        final NodeSyncState state;
        final ValidationScheduler scheduler;  // Generate/schedule NodeSync validations as appropriate
        private final ValidationExecutor executor;    // Executes the validation generated by the scheduler.
        private final NodeSyncMaintenanceTasks maintenanceTasks;

        private Instance()
        {
            this.state = new NodeSyncState(NodeSyncService.this);
            this.scheduler = new ValidationScheduler(state);
            this.executor = new ValidationExecutor(scheduler, config);
            this.maintenanceTasks = new NodeSyncMaintenanceTasks(this);
        }

        NodeSyncService service()
        {
            return NodeSyncService.this;
        }

        private CompletableFuture<Boolean> start()
        {
            // Note that we want to register as a schema listener asap, before we compute the initial proposers so that we can't
            // miss a table creation/update due to a race. This might make us create more than one ContinuousTableValidationProposer
            // for a given table, but this is fine as ValidationScheduler will only keep one.
            // Same for the 'endpoint lifecycle' one, we want to set it before we check that there is only one node.
            Schema.instance.registerListener(scheduler);
            StorageService.instance.register(scheduler);

            executor.start();
            maintenanceTasks.start();

            if (StorageService.instance.getTokenMetadata().getAllEndpoints().size() == 1)
            {
                // This is a single node cluster so don't create useless validations.
                logger.info("Enabled NodeSync service (currently inactive as this is the only node in the cluster; " +
                            "will activate automatically once more nodes join)");
                return CompletableFuture.completedFuture(true);
            }
            else
            {
                return scheduler.addAllContinuous(NodeSyncHelpers.nodeSyncEnabledTables())
                                .handle((tables, exc) -> {
                                    if (exc != null)
                                    {
                                        stop(true);
                                        throw Throwables.cleaned(exc);
                                    }
                                    String details = tables.isEmpty()
                                                     ? "currently inactive as no replicated table has NodeSync enabled; will activate automatically once this change"
                                                     : tables.size() + " tables have NodeSync enabled";
                                    logger.info("Enabled NodeSync service ({})", details);
                                    return true;
                                });
            }
        }

        private CompletableFuture<Void> stop(boolean force)
        {
            // We can un-register the scheduler right away.
            Schema.instance.unregisterListener(scheduler);
            StorageService.instance.unregister(scheduler);

            // We could probably stop the maintenance tasks now without much consequences, but waiting on having nothing
            // that runs anymore feels a tad cleaner.
            return executor.shutdown(force)
                           .thenRun(maintenanceTasks::stop)
                           .thenRun(NodeSyncService.this::finishShutdown);
        }
    }

    private final NodeSyncTracing tracing = new NodeSyncTracing();

    public NodeSyncService()
    {
        this(NodeSyncStatusTableProxy.DEFAULT);
    }

    @VisibleForTesting
    NodeSyncService(NodeSyncStatusTableProxy statusTableProxy)
    {
        this.statusTableProxy = statusTableProxy;
        registerJMX();
    }

    public NodeSyncMetrics metrics()
    {
        return metrics;
    }

    public NodeSyncConfig config()
    {
        return config;
    }

    NodeSyncTracing tracing()
    {
        return tracing;
    }

    private void registerJMX()
    {
        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
        try
        {
            ObjectName jmxName = new ObjectName(MBEAN_NAME);
            mbs.registerMBean(this, jmxName);
        }
        catch (InstanceAlreadyExistsException e)
        {
            logger.error("Cannot register NodeSync through JMX as a prior instance already exists: "
                         + "this shouldn't happen and should be reported to support. "
                         + "It won't prevent NodeSync from running, but it will prevent controlling this instance through JMX");
        }
        catch (Exception e)
        {
            logger.error("Cannot register NodeSync through JMX due to unexpected error: "
                         + "this shouldn't happen and should be reported to support. "
                         + "It won't prevent NodeSync from running, but it will prevent controlling this instance through JMX", e);
        }
    }

    /**
     * Enables the NodeSync service if it is not running already.
     *
     * @return a future on the completion of the service start, which will return {@code true} if the service was
     * started and {@code false} if it was already running prior to this call (in which case the method is a no-op and
     * return immediately).
     */
    public synchronized CompletableFuture<Boolean> enableAsync()
    {
        if (isRunning())
            return CompletableFuture.completedFuture(false);

        try
        {
            instance = new Instance();
            return instance.start();
        }
        catch (RuntimeException e)
        {
            // If we failed starting, user will expect the service to not really be running, so make sure that's basically true.
            if (instance != null)
                instance.stop(true);
            return CompletableFutures.exceptionallyCompletedFuture(e);
        }
    }

    /**
     * Enables the NodeSync service if it is not running already.
     * <p>
     * This a 'blocking forever' variant of {@link #enable(long, TimeUnit)}.
     *
     * @return {@code true} if the service was started, {@code false} if it was already running prior to this call (in
     * which case the method was a no-op).
     */
    public boolean enable()
    {
        try
        {
            return enable(Long.MAX_VALUE, TimeUnit.DAYS);
        }
        catch (TimeoutException e)
        {
            throw new AssertionError("I hope the wait wasn't too long");
        }
    }

    /**
     * Enables the NodeSync service if it wasn't already running, blocking until the service is started up.
     *
     * @param timeout how long the method should wait for the service to report proper startup. If the service hasn't
     *                finish startup within this timeout, a {@link TimeoutException} is thrown.
     * @param timeoutUnit the unit for {@code timeout}.
     * @return {@code true} if the service was started, {@code false} if it was already running.
     */
    public boolean enable(long timeout, TimeUnit timeoutUnit) throws TimeoutException
    {
        try
        {
            Uninterruptibles.getUninterruptibly(enableAsync(), timeout, timeoutUnit);
            return true;
        }
        catch (ExecutionException e)
        {
            throw Throwables.cleaned(e);
        }
    }

    /**
     * Disable the NodeSync service if it is running.
     *
     * @param force if {@code true}, try to force the shutdown of the service, interrupting any currently running
     *              validation if necessary. If {@code false}, a clean shutdown (where no new segment validation starts
     *              executing but the ongoing one continue to completion) is initiated instead.
     * @return a future on the shutdown of the service. If the service wasn't running in the first place, the returned
     * future will return immediately.
     */
    public synchronized CompletableFuture<Boolean> disableAsync(boolean force)
    {
        if (!isRunning())
            return CompletableFuture.completedFuture(false);

        return instance.stop(force)
                       .thenRun(() -> logger.info("Disabled NodeSync service"))
                       .thenApply(x -> true);
    }

    /**
     * Disables the NodeSync service (if it is running) and blocks (indefinitely) on the shutdown completing.
     * <p>
     * This method only exists for the sake of JMX and more precisely JConsole. The {@link #disableAsync(boolean)} variant
     * cannot be used through JMX at all and the {@link #disable(boolean, long, TimeUnit)}, while exposed by JMX, cannot
     * be called from JConsole due to the use of {@link TimeUnit}. As some users may find it convenient to still be
     * able to disable through JConsole (after, you can call {@link #enable()} from there), we expose this variant as
     * well.
     *
     * @return {@code true} if the service was stopped, {@code false} if it wasn't already running.
     */
    public boolean disable()
    {
        try
        {
            return disable(false, Long.MAX_VALUE, TimeUnit.DAYS);
        }
        catch (TimeoutException e)
        {
            throw new AssertionError("I hope the wait wasn't too long");
        }
    }

    /**
     * Disables the NodeSync service (if it is running) and blocks on the shutdown completing.
     * <p>
     * For internal code, the {@link #disableAsync(boolean)} variant should be preferred to this method as it's a bit more
     * flexible (doesn't block by default and the returned future allows for a few conveniences), but this method exists
     * for JMX where we basically have to block (or do something a lot more complex).
     *
     * @param force whether the shutdown should be forced, which means that ongoing validation will be interrupted and the
     *              service is stopped as quickly as possible. if {@code false}, a clean shutdown is performed where
     *              ongoing NodeSync segments validations are left time to finish so no ongoing work is thrown on the floor.
     *              Note that a clean shutdown shouldn't take long in general and is thus recommended.
     * @param timeout how long the method should wait for the service to report proper shutdown. If the service hasn't
     *                finish shutdown within this timeout, a {@link TimeoutException} is thrown.
     * @param timeoutUnit the unit for {@code timeout}.
     * @return {@code true} if the service was stopped, {@code false} if it wasn't already running.
     */
    public boolean disable(boolean force, long timeout, TimeUnit timeoutUnit) throws TimeoutException
    {
        if (!isRunning())
            return false;

        try
        {
            Uninterruptibles.getUninterruptibly(disableAsync(force), timeout, timeoutUnit);
            return true;
        }
        catch (ExecutionException e)
        {
            // We never complete the future returned by disable() exceptionally, so this genuinely shouldn't happen
            throw new AssertionError(e);
        }
    }

    private synchronized void finishShutdown()
    {
        this.instance = null;
    }

    public boolean isRunning()
    {
        return instance != null;
    }

    /**
     * Whether or not it is safe to purge tombstones for the provided table.
     * <p>
     * This compares the gcBefore we're going to use with the smallest time at which a segment for this table has been
     * validated. The idea being that we don't want to purge anything that may not have been propagated to all nodes
     * yet as this could lead to data resurrection.
     *
     * @param table the table for which we want to purge data.
     * @param gcBefore the time before we want to purge data.
     * @return {@code true} if it would be safe to purge data from {@code table} older than {@code gcBefore} (because
     * either NodeSync isn't used, or it can prove that any data older than {@code gcBefore} has been propagated to
     * all replica), {@code false} otherwise.
     */
    public boolean canPurge(TableMetadata table, int gcBefore)
    {
        // Note that we don't simply check if the TableState is loaded in NodeSyncState because it can be loaded for
        // user validations that can be triggered even on a table without NodeSync enabled. We really want to figure
        // out if the table is continuously validated.
        Instance current = instance; // protect against concurrent shutdowns
        if (current == null) // NodeSync isn't running
            return true;

        ContinuousValidationProposer proposer = current.scheduler.getContinuousProposer(table);
        if (proposer == null) // The table isn't NodeSync-enabled
            return true;

        // We shouldn't purge anything that may not have been propagated yet. That is, we want to purge data created
        // before gcBefore, so we should make sure all segments have been validated since then.
        return gcBefore <= proposer.state.oldestSuccessfulValidation();
    }

    /**
     * Updates the global and per-table JMX metrics after a segment validation.
     *
     * @param table the table on which the validation for which we record metrics was.
     * @param validationMetrics the metrics of the validation we performed and that needs to be added to the JMX metrics.
     */
    void updateMetrics(TableMetadata table, ValidationMetrics validationMetrics)
    {
        validationMetrics.addTo(metrics);
        ColumnFamilyStore cfs = ColumnFamilyStore.getIfExists(table.id);
        // We generally should only get there if the table exists, but table drop kind of race with everything so it's
        // possible to get there if the table was effectively removed between the end of the validation and this point.
        // In which case just ignoring the metrics is fine anyway.
        if (cfs != null)
            validationMetrics.addTo(cfs.metric.nodeSyncMetrics);
    }

    /**
     * Sets the validation rate for NodeSync.
     *
     * @param kbPerSecond the new rate to set in kilobytes-per-seconds.
     */
    public void setRate(int kbPerSecond)
    {
        Instance current = instance;
        if (current != null)
        {
            current.scheduler.setRate(RateValue.of(kbPerSecond, RateUnit.KB_S));
            current.maintenanceTasks.onRateUpdate();
        }
        else
        {
            config.setRate(RateValue.of(kbPerSecond, RateUnit.KB_S));
        }
    }

    /**
     * Returns the currently "configured" validation rate for NodeSync.
     * <p>
     * Please note that this only return the configured "target" rate of NodeSync but may not necessarily correspond
     * to the rate at which NodeSync is currently operating (which cannot be greater that the value returned by this
     * method by definition, but can be lower if there is little to validate in the cluster or if the node is not
     * able to achieve the configured rate). If you want to know said "live" rate, you should look at the
     * {@link NodeSyncMetrics#dataValidated} metric.
     *
     * @return the configured rate in kilobytes-per-seconds.
     */
    public int getRate()
    {
        return (int)config.getRate().in(RateUnit.KB_S);
    }

    public void startUserValidation(Map<String, String> optionMap)
    {
        Instance current = instance;
        if (current == null)
            throw new NodeSyncNotRunningException("Cannot start user validation, NodeSync is not currently running.");

        // TODO: we should use JMX notifications for progress reporting. Not really a priority though.
        current.scheduler.addUserValidation(UserValidationOptions.fromMap(optionMap));
    }

    public void startUserValidation(String id, String keyspace, String table, String ranges, Integer rateInKB)
    {
        HashMap<String, String> m = new HashMap<>();
        m.put(UserValidationOptions.ID, id);
        m.put(UserValidationOptions.KEYSPACE_NAME, keyspace);
        m.put(UserValidationOptions.TABLE_NAME, table);
        if (ranges != null && !ranges.isEmpty())
            m.put(UserValidationOptions.REQUESTED_RANGES, ranges);
        if (rateInKB != null)
            m.put(UserValidationOptions.RATE_IN_KB, rateInKB.toString());
        startUserValidation(m);
    }

    public void cancelUserValidation(String id)
    {
        Instance current = instance;
        if (current == null)
            throw new NodeSyncNotRunningException("Cannot cancel user validation, NodeSync is not currently running.");

        UserValidationProposer proposer = current.scheduler.getUserValidation(id);
        if (proposer == null)
            throw new NotFoundValidationException("Cannot find user validation #" + id);

        // We could return the value of cancel() from this method, but as validations are unregistered as soon as they
        // complete, we can only get false here on a race with that removal and the window for that is really small. It
        // follows that returning a boolean where 99.9% of user will always see it return true might be more confusing
        // than anything. So we throw an exception instead: after all, if this had run just a few ms later, we'd have
        // thrown a NoSuchElementException.
        if (!proposer.cancel())
            throw new CancelledValidationException("User validation #" + id + " is already completed");
    }

    public List<Map<String, String>> getRateSimulatorInfo(boolean includeAllTables)
    {
        return RateSimulator.Info.compute(includeAllTables).toJMX();
    }

    public UUID enableTracing()
    {
        return enableTracing(Collections.emptyMap());
    }

    public UUID enableTracing(Map<String, String> optionMap)
    {
        return tracing.enable(TracingOptions.fromMap(optionMap));
    }

    public UUID currentTracingSession()
    {
        return tracing.currentTracingSession();
    }

    public boolean isTracingEnabled()
    {
        return tracing.isEnabled();
    }

    public void disableTracing()
    {
        tracing.disable();
    }

    static class NodeSyncServiceException extends RuntimeException
    {
        private NodeSyncServiceException(String message)
        {
            super(message);
        }
    }

    /**
     * Thrown by {@link #startUserValidation} and {@link #cancelUserValidation} when the NodeSync service isn't running.
     */
    public final static class NodeSyncNotRunningException extends NodeSyncServiceException
    {
        private NodeSyncNotRunningException(String message)
        {
            super(message);
        }
    }

    /**
     * Thrown by {@link #cancelUserValidation} when the referenced validation is not found.
     */
    public final static class NotFoundValidationException extends NodeSyncServiceException
    {
        private NotFoundValidationException(String message)
        {
            super(message);
        }
    }

    /**
     * Thrown by {@link #cancelUserValidation} when the referenced validation is already cancelled.
     */
    public final static class CancelledValidationException extends NodeSyncServiceException
    {
        private CancelledValidationException(String message)
        {
            super(message);
        }
    }

}
